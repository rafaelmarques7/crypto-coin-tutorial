import * as crypto from "crypto";

function hexToDecimal(hex: string) {
    return parseInt(hex, 16).toString(2)
}

class Transaction {
    constructor(
        public from: string, 
        public to: string, 
        public ammount: number
    ) {}

    toString() {
        return JSON.stringify(this)
    }
}

class Block {
    constructor(
        public previousHash: string,
        public transaction: Transaction,
        public date = Date.now(),
        public nonce = 0 // this will be updated by the mine function
    ) {}

    get header() {
        // return all fields except the nonce
        return {
            previousHash: this.previousHash,
            transaction: this.transaction,
            date: this.date,
        }
    }

    get hash() {
        const blockStr = JSON.stringify(this.header)
        const hash = crypto.createHash("SHA256")
        hash.update(blockStr).end()

        return hash.digest('hex')
    }

    mine() {
        // Mining works by trying to find a nonce, so that
        // when you hash the combination of the block headerer and the nonce
        // you get a hash with meets a certain criteria 
        // (the criteria is usually a hash that contains a number of trailing zero's)
        let nonce = 0
        while (true) {
            const hashHex = crypto.createHash("MD5").update(this.header + nonce.toString()).digest('hex')
            const hashBinary = hexToDecimal(hashHex)

            // check if hash passes the mining condition
            if (hashBinary.substring(0, 4) === "0000") {
                this.nonce = nonce
                return
            }
            nonce += 1
        }
    }
}

class Chain {
    // there can only be one chain - singleton 
    public static instance = new Chain()

    chain: Block[]

    constructor() {
        this.chain = [
            // Genesis block
            new Block("", new Transaction("Genesis", "Satoshi", 100))
        ]
    }

    get lastBlock() {
        return this.chain[-1]
    }

    addBlock(transaction: Transaction, payerPublicKey: string, signature: Buffer) {
        // generate a signature verifier based on the SHA256 algorithm and transaction data
        const verifier = crypto.createVerify("SHA256")
        verifier.update(transaction.toString())

        // verify that the signature was generated by the owner of the payerPublicKey
        const isValidSignature = verifier.verify(payerPublicKey, signature)

        // generate new block only if signature is valid
        if (isValidSignature) {
            const prevHash = this.lastBlock.hash
            const newBlock = new Block(prevHash, transaction) 
            this.chain.push(newBlock)
        }
    }
}

class Wallet {
    public publicKey: string
    public privateKey: string

    constructor() {
        const keyPair = crypto.generateKeyPairSync('rsa', {
            modulusLength: 2048,
            publicKeyEncoding: { type: 'spki', format: 'pem' },
            privateKeyEncoding: { type: 'pkcs8', format: 'pem' },
        })

        this.publicKey = keyPair.publicKey
        this.privateKey = keyPair.privateKey
    }

    sendMoney(ammount: number, payeePublicKey: string) {
        const transaction = new Transaction(this.publicKey, payeePublicKey, ammount)
        
        // create a signature based on the transaction data using SHA256 algorithm
        const sign = crypto.createSign('SHA256')
        sign.update(transaction.toString()).end() 

        // sign the transaction using the private key
        const signature = sign.sign(this.privateKey)

        // add transaction to block chain
        Chain.instance.addBlock(transaction, this.publicKey, signature)
    }
}